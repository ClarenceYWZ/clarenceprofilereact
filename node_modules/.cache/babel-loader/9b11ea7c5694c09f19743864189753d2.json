{"ast":null,"code":"import sync from 'framesync';\nvar unresolvedJobs = new Set();\nvar layoutState = {\n  isMeasuringLayout: false\n};\n\nfunction pushJob(stack, job, pointer) {\n  if (!stack[pointer]) stack[pointer] = [];\n  stack[pointer].push(job);\n}\n\nfunction batchLayout(callback) {\n  unresolvedJobs.add(callback);\n  return function () {\n    return unresolvedJobs.delete(callback);\n  };\n}\n\nfunction flushLayout() {\n  if (!unresolvedJobs.size) return;\n  var pointer = 0;\n  var reads = [[]];\n  var writes = [];\n\n  var setRead = function (job) {\n    return pushJob(reads, job, pointer);\n  };\n\n  var setWrite = function (job) {\n    pushJob(writes, job, pointer);\n    pointer++;\n  };\n  /**\n   * Resolve jobs into their array stacks\n   */\n\n\n  unresolvedJobs.forEach(function (callback) {\n    callback(setRead, setWrite);\n    pointer = 0;\n  });\n  unresolvedJobs.clear();\n  /**\n   * Mark that we're currently measuring layouts. This allows us to, for instance, ignore\n   * hover events that might be triggered as a result of resetting transforms.\n   *\n   * The postRender/setTimeout combo seems like an odd bit of scheduling but what it's saying\n   * is *after* the next render, wait 10ms before re-enabling hover events. Waiting until the\n   * next frame completely will result in missed, valid hover events. But events seem to\n   * be fired async from their actual action, so setting this to false too soon can still\n   * trigger events from layout measurements.\n   *\n   * Note: If we figure out a way of measuring layout while transforms remain applied, this can be removed.\n   * I have attempted unregistering event listeners and setting CSS to pointer-events: none\n   * but neither seem to work as expected.\n   */\n\n  layoutState.isMeasuringLayout = true;\n  sync.postRender(function () {\n    setTimeout(function () {\n      return layoutState.isMeasuringLayout = false;\n    }, 10);\n  });\n  /**\n   * Execute jobs\n   */\n\n  var numStacks = writes.length;\n\n  for (var i = 0; i <= numStacks; i++) {\n    reads[i] && reads[i].forEach(executeJob);\n    writes[i] && writes[i].forEach(executeJob);\n  }\n}\n\nvar executeJob = function (job) {\n  return job();\n};\n\nexport { batchLayout, flushLayout, layoutState };","map":null,"metadata":{},"sourceType":"module"}